#Компьютер #Программа #OC #Алгоритм #СвойстваАлгоритма #АнализАлгоритма #BigO-Notaion #Классификацияпоструктуре #АланТьюринг

### Управление компьютером при помощи программ: Теоретическая основа и архитектура.

**Компьютер** как универсальная вычислительная машина (по определению Алана Тьюринга) представляет собой устройство способные выполнять произвольные алгоритмы при наличии подходящей _программы._

**Программа** - формализованная последовательность инструкций, предназначенная для управления ресурсами _ЭВМ (электронной вычислительной машины)_, в данном случае компьютера. В научном смысле, управление при помощи программ реализуется, через машинную модель Джона Фон Неймана, где программа и данные хранятся в единой памяти, а процессор последовательно интерпретирует команды.

С точки зрения архитектуры, программа сначала загружается в оперативную память, затем извлекается для выполнения декодируется и исполняется процессором. Взаимодействие с программой осуществляется при помощи устройств ввода и вывода.

###### Роль операционной системы (ОС)
ОС выступает как посредник, абстрагируя аппаратные устройства, лишь предоставляя интерфейсы ограниченного взаимодействия с ними. В терминах теории систем, ОС реализуют виртуализацию ресурсов, позволяя нескольким программам работать параллельно

###### **Вывод**:

Без программ компьютер остается пассивным устройством, а программы наделяют его "интеллектом" через детерминированное выполнение. Т.е., на данный момент, именно пользователь, отталкиваясь от задачи, определяет исполнителя и его характеристики.

### Понятие алгоритма: формальное определение и свойства.

Алгоритм - это абстрактная логически-математическая конструкция, представляющая собой конечную последовательность строго определенных шагов, приводящих от начального состояния (входных данных) к желаемому результату (выходным данным). Сам термин происходит от латинской транслитерации имени персидского математика Мухаммеда аль-Хорезми, жившего в 9 веке. Его труды заложили основы систематического решения уравнений.

###### Основные свойства алгоритма

1. Детерминированность (однозначность) - каждый шаг определяет уникальное действие для данного состояния.
2. Массовость (общность) - алгоритм применим классу задач, а не к одной конкретной.
3. Результативность (эффективность) - гарантия получения корректного результата.
4. Дискретность - возможность разбиения алгоритма на атомарные операции (примитивные).
5. Конечность - любой алгоритм завершается за конечное число шагов.
6. Корректность - результат соответствует ожидаемому и может быть проверен (доказан).

Также алгоритмы поддаются следующему анализу:

- Временная сложность Мера количества вычислительных ресурсов (времени), необходимых для выполнения алгоритма в зависимости от входных данных.
- Пространственная сложность Мера объема памяти необходимого для выполнения алгоритма и выраженная как функция от размера входных данных.
- Средний случай

###### Big O-Notaion (Нотация большой О)

**Big O-Notaion (Нотация большой О)** - _это математический способ описания верхнего предела (или наихудшего сценария) производительности алгоритма или структуры данных, который показывает, как будет расти время выполнения или потребление памяти при увеличении объема входных данных. Она помогает понять и сравнить эффективность разных алгоритмов, фокусируясь на скорости роста сложности, игнорируя константные множители и низкоуровневые детали_.

Big O нотация нужна для описания сложности алгоритмов. Для этого используется понятие времени. BIG-O указывает на самую быстрорастущую сложность видов алгоритма.

**Что такое O(n)**

**Константы откидываются.** Нас интересует только часть формулы, которая зависит от размера входных данных. Проще говоря, это само число n, его степени, логарифмы, факториалы и экспонент, где число находится в степени n.

**Примеры:**

_O(3n) = O(n)_

_O(10000 n^2) = O(n^2)_

_O(2n * log n) = O(n * log n)_

**Если в O есть сумма, нас интересует самое быстрорастущее слагаемое.** Это называется асимптотической оценкой сложности.

**Примеры:**

_O(n^2 + n) = O(n^2)_

_O(n^3 + 100n * log n) = O(n^3)_

_O(n! + 999) = O(n!)_

_O(1,1^n + n^100) = O(1,1^n)_

**Хороший, плохой, средний**

У каждого алгоритма есть худший, средний и лучший _сценарии_ работы — в зависимости от того, насколько удачно выбраны входные данные. Часто их называют _случаями_.

Рассмотрим на реальной задаче: найти, на каком месте в массиве _arr_ находится элемент _3_, и вернуть его индекс.

Меткий человеческий глаз сразу видит, что искомый элемент содержится в ячейке с индексом 2, то есть в _arr[2]_. А менее зоркий компьютер будет перебирать ячейки друг за другом: _arr[0], arr[1]_… и так далее, пока не встретит тройку или конец массива, если тройки в нём нет.

Теперь разберём случаи:

**Худший случай (worst case)** — это когда входные данные требуют максимальных затрат времени и памяти. Больше всего шагов потребуется, если искомое число стоит в конце массива. В этом случае придётся перебрать все n ячеек, прочитать их содержимое и сравнить с искомым числом. Получается, worst case равен _O(n)_. В нашем массиве худшему случаю соответствует _x = 2_.

**Лучший случай** **(best case)** — полная противоположность worst case, самые удачные входные данные. Правильно отсортированный массив, с которым алгоритму сортировки вообще ничего делать не нужно. В случае поиска — когда алгоритм находит нужный элемент с первого раза.  Если бы искомое число стояло в самом начале массива, то мы бы получили ответ уже в первой ячейке. Best case линейного поиска — _O(1)_. Именно так обозначается константное время в Big O Notation. В нашем массиве best case наблюдается при _x = 7_.

**Средний случай** **(average case)** — самый хитрый из тройки. Интуитивно понятно, что он сидит между best case и worst case, но далеко не всегда понятно, где именно. Часто он совпадает с worst case и всегда хуже best case, если best case не совпадает с worst case. Да, иногда они совпадают. В среднем случае результаты будут равномерно распределены по массиву. Средний элемент можно рассчитать по формуле (n + 1) / 2, но так как мы отбрасываем константы, то получаем просто _n._ Значит, average case равен _O(n)_. Хотя иногда в среднем случае константы оставляют, потому что запись O(n / 2) даёт чуть больше информации.

Как определяют средний случай? Считают статистически усреднённый результат: берут алгоритм, прокручивают его с разными данными, составляют сводку результатов и смотрят, вокруг какой функции распределились результаты. В общем, расчёт average case — дело сложное. А мы приступаем к конкретным алгоритмам.

Мышление в терминах Big O

- Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1)
- Перебор коллекции это O(n)
- Вложенные циклы по той же коллекции это O(n^2)
- Разделяй и властвуй (Divide and Conquer) всегда O(log n)
- Итерации которые используют Divide and Conquer это O(n log n)

###### Классификация по структуре

- Линейные алгоритмы, которые выполняются последовательно
- C ветвлением, например: условные конструкции
- Циклические в которых задействованы повторения
- Рекурсивные, в которых происходит обращение алгоритма к самому себе