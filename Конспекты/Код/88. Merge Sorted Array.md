#Python #Код #leetcode
![[Pasted image 20260209205031.png]]

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        # Указатель на последний элемент nums1 (без нулей)
        i = m - 1
        
        # Указатель на последний элемент nums2
        j = n - 1
        
        # Указатель на конец массива nums1
        k = m + n - 1

        # Пока есть элементы в обоих массивах
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1

        # Если в nums2 остались элементы — переносим их
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

### Объяснение
Этот код выполняет слияние двух отсортированных массивов в один, изменяя массив nums1 на месте. Функция получает:
nums1 - массив длины m + n, где первые m элементов отсортированы, а остальные n — нули (резерв),
nums2 - массив из n отсортированных элементов.
Слияние происходит с конца массива nums1, чтобы не затирать ещё не обработанные данные.
Для этого используются три указателя:
i - указывает на последний значимый элемент в nums1,
j - указывает на последний элемент в nums2,
k - указывает на последнюю позицию в nums1, куда нужно записывать результат.
Алгоритм сравнивает элементы nums1[i] и nums2[j], помещает больший из них в позицию k, после чего сдвигает соответствующие указатели. Так продолжается, пока в обоих массивах есть элементы. Если после этого в nums2 остаются элементы, они копируются в nums1.
Оставшиеся элементы в nums1 копировать не нужно, так как они уже находятся на правильных местах. В итоге nums1 становится полностью отсортированным массивом, содержащим все элементы из nums1 и nums2.
